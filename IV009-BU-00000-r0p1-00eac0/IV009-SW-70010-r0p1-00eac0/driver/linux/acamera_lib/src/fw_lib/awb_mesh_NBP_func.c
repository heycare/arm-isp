//----------------------------------------------------------------------------
//   The confidential and proprietary information contained in this file may
//   only be used by a person authorised under and to the extent permitted
//   by a subsisting licensing agreement from ARM Limited or its affiliates.
//
//          (C) COPYRIGHT [2018] ARM Limited or its affiliates.
//              ALL RIGHTS RESERVED
//
//   This entire notice must be reproduced on all copies of this file
//   and copies of this file may only be made by a person if such person is
//   permitted to do so under the terms of a subsisting license agreement
//   from ARM Limited or its affiliates.
//----------------------------------------------------------------------------

/*
    Auto White Balance module:
        1. Plankian curve based
        2. Mesh lookup table based
        3. NBP decision tables

    Controls:
        AWB_SMOOTH_FILTER     - Enable smooth filter (fifo depth is FIFO_DEPTH)
        AWB_PRINT_DEBUG        - Enable test mode (with tracing debug information)
        AWB_TEST_DATA       - Runs test data through the system
        AWB_SIM_OLD_MESH    - Change probablities to simulation old awb mesh algorithm

    Default configuration:
        AWB_SMOOTH_FILTER - disable
        AWB_PRINT_DEBUG      - disable
        AWB_TEST_DATA     - disable
        AWB_SIM_OLD_MESH  - disable

    Sensor-depended DATA SECTION:    (TBD: DATA SECTION should be generated by the calibration tool)
        1. light_src
        2. rg_pos
        3. bg_pos
        4. rgbg_weight
        5. rgbg_ls_weight
        6. color_temp_mesh
        7. p_rg_low
        8. p_rg_high
        9. p_lux_low
        10. p_lux_high
        11. color_temp
        12. ct_rg_pos_calc
        13. ct_bg_pos_calc

    Structure of the module:
        1. Controls
        2. DATA SECTION (see $SENSOR_mesh_lookup.h)
        3. Routines
        4. AWB functions (calling order:  awb.scxml)


*/

#include "acamera_fw.h"
#include "acamera_math.h"
#include "acamera_metering_stats_mem_config.h"
#include "system_stdlib.h"
#include "awb_mesh_NBP_fsm.h"

//=============Controls===========================================================
#define AWB_SMOOTH_FILTER
//#define AWB_PRINT_DEBUG 90
//#define AWB_TEST_DATA
//================================================================================

#ifdef AWB_PRINT_DEBUG
#endif

//================================================================================


#ifdef LOG_MODULE
#undef LOG_MODULE
#define LOG_MODULE LOG_MODULE_AWB_MESH_NBP
#endif

static __inline uint32_t acamera_awb_statistics_data_read( AWB_fsm_t *p_fsm, uint32_t index_inp )
{
    return acamera_metering_stats_mem_array_data_read( p_fsm->cmn.isp_base, index_inp + ISP_METERING_OFFSET_AWB );
}

//===========Routines=============================================================


/*------ LUTS fetchers -----------------*/

static uint16_t luts_fetch( uint16_t val, uint16_t min, uint16_t max, uint16_t step, const int16_t *data, uint16_t len )
{
    if ( step != 0 ) {
        if ( val < min )
            return data[0];
        if ( val > max )
            return data[len - 1];
        return data[( val - min ) / step]; // division by zero is checked
    } else {
        LOG( LOG_ERR, "AVOIDED DIVISION BY ZERO" );
        return val;
    }
}

static int16_t rglow_lut[] = {3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 13, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 20, 20, 21, 21, 22, 23, 23, 24, 25, 26, 26, 27, 28, 29, 30, 31, 31, 32, 33, 34, 35, 36, 37, 38, 40, 41, 42, 43, 44, 45, 47, 48, 49, 51, 52, 53, 55, 56, 58, 60, 61, 63, 64, 66, 68, 70, 72, 73, 75, 77, 79, 81, 83, 86, 88, 90, 92, 95, 97, 99, 102, 104, 107, 110, 112, 115, 118, 121, 123, 126, 129, 133, 136, 139, 142, 145, 149, 152, 156, 159, 163, 167, 170, 174, 178, 182, 186, 190, 194, 199, 203, 207, 212, 216, 221, 226, 231, 235, 240, 245, 250, 253};
static int16_t rghigh_lut[] = {247, 242, 237, 233, 228, 223, 219, 215, 210, 206, 202, 198, 193, 189, 186, 182, 178, 174, 170, 167, 163, 160, 156, 153, 150, 147, 143, 140, 137, 134, 131, 128, 125, 123, 120, 117, 114, 112, 109, 107, 104, 102, 100, 97, 95, 93, 91, 89, 86, 84, 82, 80, 79, 77, 75, 73, 71, 69, 68, 66, 64, 63, 61, 60, 58, 57, 55, 54, 53, 51, 50, 49, 48, 46, 45, 44, 43, 42, 41, 40, 38, 37, 36, 36, 35, 34, 33, 32, 31, 30, 29, 29, 28, 27, 26, 26, 25, 24, 23, 23, 22, 22, 21, 20, 20, 19, 19, 18, 18, 17, 17, 16, 16, 15, 15, 14, 14, 14, 13, 13, 12, 12, 12, 11, 11, 11, 10, 10, 10, 9, 9, 9, 9, 8, 8, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4};
static int16_t luxlow_lut[] = {253, 251, 248, 243, 237, 229, 219, 207, 193, 179, 166, 154, 146, 141, 141, 146, 154, 166, 179, 193, 207, 219, 229, 237, 243, 248, 251, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 253, 251, 242, 233, 224, 215, 207, 199, 191, 183, 175, 168, 161, 154, 147, 140, 134, 128, 122, 116, 110, 105, 100, 95, 90, 85, 81, 76, 72, 68, 65, 61, 57, 54, 51, 48, 45, 43, 40, 37, 35, 33, 31, 29, 27, 25, 24, 22, 21, 19, 18, 17, 15, 14, 13, 12, 11, 11, 10, 9, 8, 8, 7, 7, 6, 6, 5, 5, 4, 4, 4, 3, 3, 3};
static int16_t luxhigh_lut[] = {12, 12, 13, 14, 15, 16, 19, 24, 31, 41, 55, 72, 91, 110, 125, 134, 135, 128, 115, 99, 81, 65, 52, 42, 36, 33, 31, 31, 31, 32, 33, 34, 35, 36, 37, 39, 40, 41, 42, 44, 45, 46, 48, 49, 51, 53, 54, 56, 58, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 80, 82, 84, 87, 89, 92, 94, 97, 100, 103, 106, 108, 111, 115, 118, 121, 124, 128, 131, 135, 138, 142, 146, 150, 154, 158, 162, 166, 171, 175, 179, 184, 189, 194, 198, 203, 209, 214, 219, 225, 230, 236, 241, 247, 253};

static uint16_t luts_rg_low( AWB_fsm_t *p_fsm, uint16_t val )
{
    return luts_fetch( val, 168, 326, 1, rglow_lut, ARR_SIZE( rglow_lut ) );
}

static uint16_t luts_rg_high( AWB_fsm_t *p_fsm, uint16_t val )
{
    return luts_fetch( val, 252, 419, 1, rghigh_lut, ARR_SIZE( rghigh_lut ) );
}

static uint16_t luts_lux_low( AWB_fsm_t *p_fsm, uint16_t val )
{
    return luts_fetch( val, 88, 1483, 12, luxlow_lut, ARR_SIZE( luxlow_lut ) );
}

static uint16_t luts_lux_high( AWB_fsm_t *p_fsm, uint16_t val )
{
    return luts_fetch( val, 1, 1650, 16, luxhigh_lut, ARR_SIZE( luxhigh_lut ) );
}

/*------ LUTS fetchers END -------------*/


typedef struct interp_2d_point_t {
    uint16_t x, y;
    int32_t weight;
} interp_2d_point_t;

/*------ Smooth filter system ----------*/
#ifdef AWB_SMOOTH_FILTER
static uint32_t rg_avg = 0;
static uint32_t gb_avg = 0;

void fifo_push( AWB_fsm_t *p_fsm, uint16_t rg, uint16_t gb )
{
    uint8_t awb_avg_coeff = _GET_UCHAR_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_AWB_AVG_COEF )[0];

    if ( awb_avg_coeff == 0 ) // no average
    {
        rg_avg = rg;
        gb_avg = gb;
    } else if ( rg_avg == 0 && gb_avg == 0 ) // initialization
    {
        rg_avg = (uint32_t)rg * awb_avg_coeff;
        gb_avg = (uint32_t)gb * awb_avg_coeff;
    } else // normal IIR filtration
    {
        rg_avg += rg - rg_avg / awb_avg_coeff; // division by zero is checked
        gb_avg += gb - gb_avg / awb_avg_coeff; // division by zero is checked
    }
}

static interp_2d_point_t get_point( AWB_fsm_t *p_fsm )
{
    uint8_t awb_avg_coeff = _GET_UCHAR_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_AWB_AVG_COEF )[0];
    interp_2d_point_t point;
    if ( awb_avg_coeff ) {
        point.x = ( uint16_t )( rg_avg / awb_avg_coeff ); // division by zero is checked
        point.y = ( uint16_t )( gb_avg / awb_avg_coeff ); // division by zero is checked
    } else {
        point.x = (uint16_t)rg_avg;
        point.y = (uint16_t)gb_avg;
    }
    point.weight = 0;
    return point;
}
#endif //AWB_SMOOTH_FILTER
/*----- Smooth filter system end ------*/

/*----- Mesh fetching functions -------*/

//linear interpolation
static int32_t interpl( int32_t x, int32_t x0, int32_t y0, int32_t x1, int32_t y1 )
{
    //return y0+(y1-y0)*(U16_MAX-x*x0)/(x*(x1-x0));
    if ( x1 == x0 )
        return y0;
    return y0 + ( ( ( y1 - y0 ) * ( x - x0 ) ) / ( x1 - x0 ) ); // division by zero is checked
}

//Get nearest points from lookup table based on (rg&bg) position
static interp_2d_point_t init_interp_2d_point( AWB_fsm_t *p_fsm, int32_t i, int32_t j, const int16_t *p_table, const int16_t *posx, const int16_t *posy )
{
    uint32_t x_case, y_case;
    interp_2d_point_t p;

    uint32_t TABLE_LENGTH = _GET_LEN( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_RG_POS );

    x_case = ( i <= 0 ) * 0 + ( ( i <= TABLE_LENGTH ) && ( i >= 0 ) ) + ( i > TABLE_LENGTH ) * 2;
    y_case = ( j <= 0 ) * 0 + ( ( j <= TABLE_LENGTH ) && ( j >= 0 ) ) + ( j > TABLE_LENGTH ) * 2;

    p.x = 0;
    p.y = 0;
    p.weight = 0;
    switch ( x_case ) {
    case 0:
        p.x = posx[0] - 20;
        i = 0;
        break;
    case 2:
        p.x = posx[TABLE_LENGTH - 1] + 20;
        i = TABLE_LENGTH - 1;
        break;
    default:
        p.x = posx[i];
        break;
    };

    switch ( y_case ) {
    case 0:
        p.y = posy[0] - 20;
        j = 0;
        break;
    case 2:
        p.y = posy[TABLE_LENGTH - 1] + 20;
        ;
        j = TABLE_LENGTH - 1;
        break;
    default:
        p.y = posy[j];
        break;
    };


    p.weight = p_table[j * TABLE_LENGTH + i];
    return p;
}


static int32_t get_index( AWB_fsm_t *p_fsm, int32_t v, const int16_t *p_lut )
{
    uint32_t TABLE_LENGTH = _GET_LEN( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_RG_POS );
    uint32_t indx = 0;
    int32_t i;
    for ( i = 1; i < TABLE_LENGTH; i++ ) {
        if ( v < p_lut[i] ) {
            indx = i - 1;
            return indx;
        }
    }
    indx = TABLE_LENGTH - 2;

    return indx;
}

//Get lookup value base on (rg&bg)
static int32_t AWB_mesh( AWB_fsm_t *p_fsm, uint32_t rg, uint32_t bg, int16_t *posx, int16_t *posy, const int16_t *p_table, uint8_t flag )
{
    int32_t weight = 0, db1, db2;
    int32_t x, y;
    interp_2d_point_t p00, p01, p10, p11;

    x = get_index( p_fsm, rg, posx );
    y = get_index( p_fsm, bg, posy );
    p00 = init_interp_2d_point( p_fsm, x, y, p_table, posx, posy );
    p01 = init_interp_2d_point( p_fsm, x + 1, y, p_table, posx, posy );
    p10 = init_interp_2d_point( p_fsm, x, y + 1, p_table, posx, posy );
    p11 = init_interp_2d_point( p_fsm, x + 1, y + 1, p_table, posx, posy );

    rg = ACAMERA_MAX( rg, _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_RG_POS )[0] );
    rg = ACAMERA_MIN( rg, _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_RG_POS )[_GET_LEN( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_RG_POS ) - 1] );
    bg = ACAMERA_MAX( bg, _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_BG_POS )[0] );
    bg = ACAMERA_MIN( bg, _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_BG_POS )[_GET_LEN( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_BG_POS ) - 1] );

    // NOTE: you changed these from rg/bg to irg/ibg
    db1 = interpl( rg, p00.x, p00.weight, p01.x, p01.weight );
    db2 = interpl( rg, p10.x, p10.weight, p11.x, p11.weight );

    weight = interpl( bg, p00.y, db1, p10.y, db2 );

    return weight;
}


// A min/max/step look up table version of init_interp_2d_point_LUT
static interp_2d_point_t init_interp_2d_point_LUT( AWB_fsm_t *p_fsm, int32_t i, int32_t j, int16_t minx, int16_t maxx, int16_t stepx, int16_t miny, int16_t maxy, int16_t stepy, const int16_t *p_table )
{
    uint32_t TABLE_LENGTH = _GET_LEN( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_RG_POS );

    interp_2d_point_t p;

    p.x = 0;
    p.y = 0;
    p.weight = 0;
    if ( i < 0 ) {
        i = 0;
        p.x = minx - 20;
    } else if ( i >= TABLE_LENGTH ) {
        i = TABLE_LENGTH - 1;
        p.x = maxx + 20;
    } else {
        p.x = minx + i * stepx;
    }
    if ( j < 0 ) {
        j = 0;
        p.y = miny - 20;
    } else if ( j >= TABLE_LENGTH ) {
        j = TABLE_LENGTH - 1;
        p.y = maxy + 20;
    } else {
        p.y = miny + j * stepy;
    }

    p.weight = p_table[j * TABLE_LENGTH + i];
    return p;
}

// A min/max/step look up table version of AWB_mesh
int32_t AWB_mesh_LUT( AWB_fsm_t *p_fsm, int32_t rg, int32_t bg, int16_t minx, int16_t maxx, int16_t stepx, int16_t miny, int16_t maxy, int16_t stepy, const int16_t *p_table )
{
    uint32_t TABLE_LENGTH = _GET_LEN( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_RG_POS );
    if ( ( stepx != 0 ) && ( stepy != 0 ) ) {
        int32_t weight, db1, db2;
        int32_t x, y;
        interp_2d_point_t p00, p01, p10, p11;
        interp_2d_point_t interp_2d_point;

        weight = 0;
        interp_2d_point.x = 0;
        interp_2d_point.y = 0;
        interp_2d_point.weight = 0;
        p00 = interp_2d_point;
        p01 = interp_2d_point;
        p10 = interp_2d_point;
        p11 = interp_2d_point;

        x = ( rg - minx ) / stepx; // division by zero is checked
        if ( x < 0 ) {
            x = 0;
            rg = minx;
        } else if ( x > TABLE_LENGTH - 1 ) {
            x = TABLE_LENGTH - 1;
            rg = maxx;
        }

        y = ( bg - miny ) / stepy; // division by zero is checked
        if ( y < 0 ) {
            y = 0;
            bg = miny;
        } else if ( y > TABLE_LENGTH - 1 ) {
            y = TABLE_LENGTH - 1;
            bg = maxy;
        }

        p00 = init_interp_2d_point_LUT( p_fsm, x, y, minx, maxx, stepx, miny, maxy, stepy, p_table );
        p01 = init_interp_2d_point_LUT( p_fsm, x + 1, y, minx, maxx, stepx, miny, maxy, stepy, p_table );
        p10 = init_interp_2d_point_LUT( p_fsm, x, y + 1, minx, maxx, stepx, miny, maxy, stepy, p_table );
        p11 = init_interp_2d_point_LUT( p_fsm, x + 1, y + 1, minx, maxx, stepx, miny, maxy, stepy, p_table );

        // NOTE: you changed these from rg/bg to irg/ibg
        db1 = interpl( rg, p00.x, p00.weight, p01.x, p01.weight );
        db2 = interpl( rg, p10.x, p10.weight, p11.x, p11.weight );

        weight = interpl( bg, p00.y, db1, p10.y, db2 );


        return weight;
    } else {
        LOG( LOG_ERR, "AVOIDED DIVISION BY ZERO" );
        return rg;
    }
}

// Get weight for additional source light (defined by light_src)
static int32_t mesh_AWB_getKnownSourceLight_weight_LUT( AWB_fsm_t *p_fsm, uint16_t rg, uint16_t bg, int32_t light_rg, int32_t light_bg )
{
    uint32_t TABLE_LENGTH = _GET_LEN( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_RG_POS );


    int32_t weight = 0;
    uint8_t valid_points;
    //Coordinated of possible distribution of KnownSourceLight
    int32_t MinX = light_rg - 30;
    int32_t MaxX = light_rg + 30;
    int32_t MinY = light_bg - 30;
    int32_t MaxY = light_bg + 30;

    valid_points = ( rg >= MinX ) && ( rg <= MaxX ) && ( bg >= MinY ) && ( bg <= MaxY );

    if ( valid_points ) {
        weight = AWB_mesh_LUT( p_fsm, (int32_t)rg, (int32_t)bg, MinX, MaxX, ( MaxX - MinX ) / ( TABLE_LENGTH - 1 ), MinY, MaxY, ( MaxY - MinY ) / ( TABLE_LENGTH - 1 ), (int16_t *)_GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_MESH_LS_WEIGHT ) ); // division by zero is checked
    } else                                                                                                                                                                                                                                                        //if out of range
    {
        weight = 0;
    }
    return weight;
}
//--- End mesh fetching functions -----
//================================================================================

//==========AWB functions (calling order:  awb.scxml)=============================
// Handle the hardware interrupt
void AWB_fsm_process_interrupt( const AWB_fsm_t *p_fsm, uint8_t irq_event )
{
    if ( acamera_fsm_util_is_irq_event_ignored( (fsm_irq_mask_t *)( &p_fsm->mask ), irq_event ) )
        return;

    switch ( irq_event ) {
    case ACAMERA_IRQ_AWB_STATS:
        awb_read_statistics( (AWB_fsm_t *)p_fsm ); // we know what we are doing
        fsm_raise_event( p_fsm, event_id_awb_stats_ready );
        break;
    case ACAMERA_IRQ_FRAME_END:
        awb_coeffs_write( p_fsm );
        break;
    }
}

// Write matrix coefficients
void awb_coeffs_write( const AWB_fsm_t *p_fsm )
{
    acamera_isp_ccm_coefft_wb_r_write( p_fsm->cmn.isp_base, p_fsm->awb_warming[0] );
    acamera_isp_ccm_coefft_wb_g_write( p_fsm->cmn.isp_base, p_fsm->awb_warming[1] );
    acamera_isp_ccm_coefft_wb_b_write( p_fsm->cmn.isp_base, p_fsm->awb_warming[2] );
}

void awb_roi_update( AWB_fsm_ptr_t p_fsm )
{
    uint16_t horz_zones = acamera_isp_metering_awb_nodes_used_horiz_read( p_fsm->cmn.isp_base );
    uint16_t vert_zones = acamera_isp_metering_awb_nodes_used_vert_read( p_fsm->cmn.isp_base );
    uint16_t x, y;

    uint16_t *ptr_awb_zone_whgh_h = _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_AWB_ZONE_WGHT_HOR );
    uint16_t *ptr_awb_zone_whgh_v = _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_AWB_ZONE_WGHT_VER );

    uint8_t x_start = ( uint8_t )( ( ( ( p_fsm->roi >> 24 ) & 0xFF ) * horz_zones + 128 ) >> 8 );
    uint8_t x_end = ( uint8_t )( ( ( ( p_fsm->roi >> 8 ) & 0xFF ) * horz_zones + 128 ) >> 8 );
    uint8_t y_start = ( uint8_t )( ( ( ( p_fsm->roi >> 16 ) & 0xFF ) * vert_zones + 128 ) >> 8 );
    uint8_t y_end = ( uint8_t )( ( ( ( p_fsm->roi >> 0 ) & 0xFF ) * vert_zones + 128 ) >> 8 );
    uint8_t zone_size_x = x_end - x_start;
    uint8_t zone_size_y = y_end - y_start;
    uint32_t middle_x = zone_size_x * 256 / 2;
    uint32_t middle_y = zone_size_y * 256 / 2;
    uint32_t len_zone_wght_hor = _GET_LEN( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_AWB_ZONE_WGHT_HOR );
    uint32_t len_zone_wght_ver = _GET_LEN( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_AWB_ZONE_WGHT_VER );
    uint16_t scale_x = ( horz_zones - 1 ) / ( len_zone_wght_hor > 0 ? len_zone_wght_hor : 1 ) + 1;
    uint16_t scale_y = ( vert_zones - 1 ) / ( len_zone_wght_ver > 0 ? len_zone_wght_ver : 1 ) + 1;

    uint16_t gaus_center_x = ( len_zone_wght_hor * 256 / 2 ) * scale_x;
    uint16_t gaus_center_y = ( len_zone_wght_ver * 256 / 2 ) * scale_y;

    for ( y = 0; y < vert_zones; y++ ) {
        uint8_t awb_coeff = 0;
        for ( x = 0; x < horz_zones; x++ ) {
            if ( y >= y_start && y <= y_end &&
                 x >= x_start && x <= x_end ) {

                uint8_t index_y = ( y - y_start );
                uint8_t index_x = ( x - x_start );
                int32_t distance_x = ( index_x * 256 + 128 ) - middle_x;
                int32_t distance_y = ( index_y * 256 + 128 ) - middle_y;
                uint32_t coeff_x;
                uint32_t coeff_y;

                if ( ( x == x_end && x_start != x_end ) ||
                     ( y == y_end && y_start != y_end ) ) {
                    awb_coeff = 0;
                } else {
                    coeff_x = ( gaus_center_x + distance_x ) / 256;
                    if ( distance_x > 0 && ( distance_x & 0x80 ) )
                        coeff_x--;
                    coeff_y = ( gaus_center_y + distance_y ) / 256;
                    if ( distance_y > 0 && ( distance_y & 0x80 ) )
                        coeff_y--;

                    coeff_x = ptr_awb_zone_whgh_h[coeff_x / scale_x];
                    coeff_y = ptr_awb_zone_whgh_v[coeff_y / scale_y];

                    awb_coeff = ( coeff_x * coeff_y ) >> 4;
                    if ( awb_coeff > 1 )
                        awb_coeff--;
                }
            } else {
                awb_coeff = 0;
            }
            acamera_isp_metering_awb_zones_weight_write( p_fsm->cmn.isp_base, y * vert_zones + x, awb_coeff );
        }
    }
}


// Initalisation code
void awb_init( AWB_fsm_t *p_fsm )
{
    // Initial AWB (rg,bg) is the identity
    p_fsm->rg_coef = 0x100;
    p_fsm->bg_coef = 0x100;

    // Set the default awb values
    if ( MAX_AWB_ZONES < acamera_isp_metering_awb_nodes_used_horiz_read( p_fsm->cmn.isp_base ) * acamera_isp_metering_awb_nodes_used_vert_read( p_fsm->cmn.isp_base ) ) {
        LOG( LOG_ERR, "MAX_AWB_ZONES is less than hardware reported zones" );
    }

    p_fsm->wb_log2[0] = 0;
    p_fsm->wb_log2[1] = 0;
    p_fsm->wb_log2[2] = 0;
    p_fsm->wb_log2[3] = 0;
    awb_coeffs_write( p_fsm );

    uint32_t width = acamera_isp_top_active_width_read( p_fsm->cmn.isp_base );
    uint32_t height = acamera_isp_top_active_height_read( p_fsm->cmn.isp_base );

    if ( p_fsm->curr_AWB_ZONES != 0 ) {
        p_fsm->valid_threshold = ( width * height / ( 10 * p_fsm->curr_AWB_ZONES ) ); // division by zero is checked
    } else {
        p_fsm->valid_threshold = 0;
        LOG( LOG_ERR, "AVOIDED DIVISION BY ZERO" );
    }

    p_fsm->awb_warming_A[0] = (int32_t)_GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_AWB_WARMING_LS_A )[0];
    p_fsm->awb_warming_A[1] = (int32_t)_GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_AWB_WARMING_LS_A )[1];
    p_fsm->awb_warming_A[2] = (int32_t)_GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_AWB_WARMING_LS_A )[2];

    p_fsm->awb_warming_D75[0] = (int32_t)_GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_AWB_WARMING_LS_D75 )[0];
    p_fsm->awb_warming_D75[1] = (int32_t)_GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_AWB_WARMING_LS_D75 )[1];
    p_fsm->awb_warming_D75[2] = (int32_t)_GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_AWB_WARMING_LS_D75 )[2];

    p_fsm->awb_warming_D50[0] = (int32_t)_GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_AWB_WARMING_LS_D50 )[0];
    p_fsm->awb_warming_D50[1] = (int32_t)_GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_AWB_WARMING_LS_D50 )[1];
    p_fsm->awb_warming_D50[2] = (int32_t)_GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_AWB_WARMING_LS_D50 )[2];

    p_fsm->awb_warming[0] = p_fsm->awb_warming_D50[0];
    p_fsm->awb_warming[1] = p_fsm->awb_warming_D50[1];
    p_fsm->awb_warming[2] = p_fsm->awb_warming_D50[2];

    acamera_isp_ccm_coefft_wb_r_write( p_fsm->cmn.isp_base, p_fsm->awb_warming[0] );
    acamera_isp_ccm_coefft_wb_g_write( p_fsm->cmn.isp_base, p_fsm->awb_warming[1] );
    acamera_isp_ccm_coefft_wb_b_write( p_fsm->cmn.isp_base, p_fsm->awb_warming[2] );

    // Set the min/max temperatures and their gains:
    if ( ( _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_COLOR_TEMP )[0] != 0 ) && ( _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_COLOR_TEMP )[_GET_LEN( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_COLOR_TEMP ) - 1] != 0 ) && ( _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_CT_RG_POS_CALC )[0] != 0 ) && ( _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_CT_BG_POS_CALC )[0] != 0 ) && ( _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_CT_RG_POS_CALC )[_GET_LEN( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_CT_RG_POS_CALC ) - 1] != 0 ) && ( _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_CT_BG_POS_CALC )[_GET_LEN( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_CT_BG_POS_CALC ) - 1] != 0 ) ) {
        p_fsm->min_temp = 1000000 / _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_COLOR_TEMP )[_GET_LEN( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_COLOR_TEMP ) - 1];            // division by zero is checked
        p_fsm->max_temp = 1000000 / _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_COLOR_TEMP )[0];                                                                               // division by zero is checked
        p_fsm->max_temp_rg = U16_MAX / _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_CT_RG_POS_CALC )[0];                                                                        // division by zero is checked
        p_fsm->max_temp_bg = U16_MAX / _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_CT_BG_POS_CALC )[0];                                                                        // division by zero is checked
        p_fsm->min_temp_rg = U16_MAX / _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_CT_RG_POS_CALC )[_GET_LEN( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_CT_RG_POS_CALC ) - 1]; // division by zero is checked
        p_fsm->min_temp_bg = U16_MAX / _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_CT_BG_POS_CALC )[_GET_LEN( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_CT_BG_POS_CALC ) - 1]; // division by zero is checked
    } else {
        LOG( LOG_ERR, "AVOIDED DIVISION BY ZERO" );
    }

    awb_roi_update( p_fsm );
}

// Set the 3x3 colour matrix to the identity matrix
void awb_set_identity( AWB_fsm_t *p_fsm )
{
    int i;

    for ( i = 0; i < 9; ++i ) {
        p_fsm->color_wb_matrix[i] = 0;
    }
    p_fsm->color_wb_matrix[0] = p_fsm->color_wb_matrix[4] = p_fsm->color_wb_matrix[8] = 0x100;
}

// Read the statistics from hardware
void awb_read_statistics( AWB_fsm_t *p_fsm )
{
    // Only selected number of zones will contribute
    uint16_t _i;

    fsm_param_mon_alg_flow_t awb_flow;

    awb_flow.frame_id_tracking = acamera_fsm_util_get_cur_frame_id( &p_fsm->cmn );

    if ( p_fsm->cur_using_stats_frame_id ) {
        LOG( LOG_INFO, "AWB: overwrite: prev frame_id: %d, cur: %d.", p_fsm->cur_using_stats_frame_id, awb_flow.frame_id_tracking );
    }

    p_fsm->cur_using_stats_frame_id = awb_flow.frame_id_tracking;

    p_fsm->sum = 0;

    p_fsm->curr_AWB_ZONES = acamera_isp_metering_awb_nodes_used_horiz_read( p_fsm->cmn.isp_base ) *
                            acamera_isp_metering_awb_nodes_used_vert_read( p_fsm->cmn.isp_base );

    // Read out the per zone statistics
    for ( _i = 0; _i < p_fsm->curr_AWB_ZONES; ++_i ) {
        uint32_t _metering_lut_entry;
        uint16_t irg, ibg;

        _metering_lut_entry = acamera_awb_statistics_data_read( p_fsm, _i * 2 );
        //What we get from HW is G/R.
        //It is also programmable in the latest HW.AWB_STATS_MODE=0-->G/R and AWB_STATS_MODE=1-->R/G
        //rg_coef is actually R_gain appiled to R Pixels.Since we get (G*G_gain)/(R*R_gain) from HW,we multiply by the gain rg_coef to negate its effect.
        irg = ( _metering_lut_entry & 0xfff );
        ibg = ( ( _metering_lut_entry >> 16 ) & 0xfff );

        irg = ( irg * ( p_fsm->rg_coef ) ) >> 8;
        ibg = ( ibg * ( p_fsm->bg_coef ) ) >> 8;
        irg = ( irg == 0 ) ? 1 : irg;
        ibg = ( ibg == 0 ) ? 1 : ibg;
        p_fsm->awb_zones[_i].rg = U16_MAX / irg;
        p_fsm->awb_zones[_i].bg = U16_MAX / ibg;
        p_fsm->awb_zones[_i].sum = acamera_awb_statistics_data_read( p_fsm, _i * 2 + 1 );
        p_fsm->sum += p_fsm->awb_zones[_i].sum;
    }

    awb_flow.frame_id_current = acamera_fsm_util_get_cur_frame_id( &p_fsm->cmn );
    awb_flow.flow_state = MON_ALG_FLOW_STATE_INPUT_READY;
    acamera_fsm_mgr_set_param( p_fsm->cmn.p_fsm_mgr, FSM_PARAM_SET_MON_AWB_FLOW, &awb_flow, sizeof( awb_flow ) );
}

#ifdef AWB_TEST_DATA
const uint16_t test_AVGrg = 167;
const uint16_t test_lux = 438;
const uint16_t rg_list[225] = {4095, 110, 113, 4095, 145, 146, 144, 130, 131, 135, 160, 154, 186, 225, 304, 4095, 112, 116, 115, 120, 147, 150, 140, 142, 142, 148, 144, 185, 202, 224, 4095, 110, 113, 112, 126, 142, 146, 143, 151, 161, 166, 170, 185, 195, 256, 144, 4095, 114, 116, 117, 142, 142, 134, 140, 167, 175, 189, 192, 187, 221, 118, 4095, 109, 111, 117, 138, 142, 135, 129, 166, 172, 208, 226, 186, 174, 128, 4095, 124, 114, 115, 134, 140, 134, 142, 170, 173, 211, 220, 190, 193, 144, 4095, 114, 116, 112, 130, 129, 140, 151, 168, 162, 182, 222, 193, 209, 4095, 4095, 110, 117, 114, 118, 124, 134, 149, 155, 136, 222, 232, 208, 218, 4095, 4095, 4095, 121, 110, 132, 146, 154, 141, 141, 144, 152, 154, 242, 237, 4095, 134, 136, 121, 112, 140, 198, 181, 152, 152, 151, 193, 151, 4095, 220, 4095, 4095, 4095, 4095, 180, 178, 189, 179, 165, 154, 200, 184, 212, 206, 219, 4095, 4095, 4095, 4095, 213, 192, 192, 185, 230, 197, 204, 179, 195, 206, 191, 4095, 4095, 208, 4095, 4095, 173, 177, 178, 189, 188, 186, 198, 195, 182, 188, 4095, 4095, 4095, 4095, 201, 4095, 4095, 185, 4095, 264, 206, 192, 191, 198, 198, 4095, 4095, 182, 4095, 4095, 4095, 165, 175, 4095, 4095, 171, 4095, 4095, 245, 233};
const uint16_t bg_list[225] = {4095, 375, 339, 4095, 316, 281, 269, 272, 284, 298, 270, 277, 260, 290, 304, 4095, 338, 337, 320, 312, 318, 284, 270, 266, 277, 299, 344, 259, 258, 298, 4095, 409, 358, 446, 321, 313, 297, 286, 285, 282, 295, 298, 267, 255, 238, 4095, 4095, 363, 390, 374, 306, 317, 344, 309, 299, 286, 272, 257, 243, 243, 832, 4095, 498, 433, 429, 319, 329, 403, 333, 318, 308, 267, 237, 237, 244, 512, 4095, 265, 349, 342, 316, 345, 383, 327, 314, 311, 262, 247, 254, 254, 4095, 4095, 326, 349, 392, 327, 376, 318, 332, 320, 317, 280, 233, 259, 248, 4095, 4095, 425, 362, 338, 408, 436, 313, 320, 325, 302, 244, 237, 257, 245, 4095, 4095, 4095, 335, 315, 404, 325, 326, 393, 348, 307, 271, 261, 244, 242, 4095, 348, 4095, 327, 322, 317, 252, 323, 324, 328, 273, 279, 282, 4095, 263, 4095, 4095, 4095, 4095, 284, 296, 285, 305, 311, 310, 266, 294, 268, 245, 243, 4095, 4095, 4095, 4095, 254, 280, 280, 296, 253, 306, 264, 306, 282, 269, 268, 4095, 4095, 4095, 4095, 4095, 287, 293, 294, 279, 281, 292, 274, 278, 291, 277, 4095, 4095, 4095, 4095, 281, 4095, 4095, 278, 4095, 236, 258, 274, 273, 260, 251, 4095, 4095, 285, 4095, 4095, 4095, 297, 297, 4095, 4095, 296, 4095, 4095, 368, 228};
const uint16_t awbsum_list[225] = {1, 352, 361, 1, 5774, 9345, 22368, 24103, 28465, 27352, 6645, 15524, 652, 127, 19, 0, 6072, 5418, 180, 2535, 32656, 14015, 13889, 12827, 32380, 44656, 32587, 6042, 1839, 56, 0, 179, 6124, 1394, 3296, 36653, 20349, 20385, 20463, 45124, 59282, 58005, 23631, 10450, 29481, 9, 2, 1932, 5840, 10512, 31342, 26509, 24189, 24071, 52358, 13509, 36016, 25666, 50435, 60401, 52, 0, 436, 5981, 7549, 36088, 24665, 38383, 22573, 49044, 44443, 50278, 16500, 38153, 45546, 32, 2, 598, 8199, 727, 31626, 21719, 36816, 46929, 31411, 41719, 56808, 21441, 37951, 33373, 27, 0, 5646, 11987, 98, 33632, 22246, 16415, 56141, 56533, 22521, 46428, 24779, 35069, 32814, 0, 0, 319, 21238, 2433, 5163, 5817, 14381, 14709, 20957, 9165, 37020, 31565, 34387, 44714, 0, 0, 0, 30161, 2070, 1567, 2790, 3670, 2583, 6641, 11503, 11098, 3504, 12762, 37567, 3, 109, 17, 5486, 1249, 2065, 14798, 1273, 6585, 8755, 7848, 5043, 406, 0, 1253, 0, 0, 0, 0, 18840, 37829, 31884, 17410, 27019, 1613, 8075, 20028, 7240, 8755, 7148, 0, 0, 2, 0, 11188, 52206, 29874, 48571, 9642, 518, 8479, 28332, 31490, 19921, 5540, 0, 0, 13, 4, 0, 2102, 13519, 23928, 22225, 15966, 18273, 41638, 37871, 38643, 45642, 0, 1, 7, 6, 88, 5, 0, 244, 0,
                                   281, 6277, 18480, 28732, 40855, 28454, 0, 0, 285, 9, 0, 3, 279, 372, 1, 1, 816, 0, 0, 46, 614};
#endif


//Get average (rg&bg)
void awb_calc_avg_weighted_gr_gb_mesh( AWB_fsm_t *p_fsm )
{
    uint64_t sum = 0;
    uint32_t npcH = 0;
    uint32_t npcL = 0;
    uint32_t npcLsum = 0;
    uint32_t npcHsum = 0;

    uint64_t avg_RG = 0;
    uint64_t avg_BG = 0;
    uint64_t GRres = 0;
    uint64_t GBres = 0;
    int32_t temp_cal = 0;
    int32_t store = 0;
    int32_t MinX = 0;
    int32_t MinY = 0;
    int32_t MaxX = 0;
    int32_t MaxY = 0;

    int32_t weight = 0;
    int32_t weight_ls = 0;
    int32_t *weight_ = p_fsm->weight_;
    uint16_t _i = 0;
    uint16_t _j = 0;
    uint16_t npccount = 0;
    uint16_t lux = 0;
    uint16_t rg = 0;
    uint16_t bg = 0;
    uint16_t p_rg_highTemp = 0;
    uint16_t p_rg_lowTemp = 0;
    uint16_t p_lux_lowTemp = 0;
    uint16_t p_lux_highTemp = 0;
    uint16_t sky_cut_high = 0;
    uint16_t sky_cut_low = 0;
    uint16_t sky_cut_high_bg = 0;
    uint16_t *rg_valid = p_fsm->rg_valid;
    uint16_t *bg_valid = p_fsm->bg_valid;
    uint8_t *mvalid = p_fsm->mvalid;
    uint8_t *cwfzones = p_fsm->cwfzones;
    uint8_t *npcHigh = p_fsm->npcHigh;
    uint8_t *npcLow = p_fsm->npcLow;
    uint8_t *sky_zones = p_fsm->sky_zones;
    uint8_t npcHmean = 0;
    uint8_t npcLmean = 0;
    uint8_t valid_zone = 0;
    uint8_t clipRG = 0;
    uint8_t clipBG = 0;

    uint8_t p_highTemp = 50;
    uint8_t p_lowTemp = 50;
    uint8_t adjust_sky = 0;

    unsigned short( *_calibration_light_src )[2] = (unsigned short( * )[2])_GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_LIGHT_SRC );


    if ( p_fsm->curr_AWB_ZONES > MAX_AWB_ZONES ) {
        LOG( LOG_ERR, "AVOIDED ARRAY ACCESS BEYOND LIMITS" );
        return;
    }

#ifdef AWB_PRINT_DEBUG
    static uint16_t ittcount = 0;
    const uint16_t debugprintperiod = AWB_PRINT_DEBUG;
    ittcount++;
    if ( ittcount > debugprintperiod )
        ittcount = 0;
#endif
    //
    // - Initialisation
    //

    for ( _i = 0; _i < p_fsm->curr_AWB_ZONES; ++_i ) {
        weight_[_i] = 0;
        mvalid[_i] = 0;
        cwfzones[_i] = 0;
        sky_zones[_i] = 1;
        npcHigh[_i] = npcLow[_i] = 0;
    }

    //
    // - Get lux
    //
    int32_t type = CMOS_CURRENT_EXPOSURE_LOG2;
    acamera_fsm_mgr_get_param( p_fsm->cmn.p_fsm_mgr, FSM_PARAM_GET_CMOS_EXPOSURE_LOG2, &type, sizeof( type ), &store, sizeof( store ) );

#ifdef AWB_TEST_DATA
    for ( _i = 0; _i < p_fsm->curr_AWB_ZONES; ++_i ) {
        p_fsm->awb_zones[_i].rg = U16_MAX / rg_list[_i];
        p_fsm->awb_zones[_i].bg = U16_MAX / bg_list[_i];
        p_fsm->awb_zones[_i].sum = awbsum_list[_i];
        // Don't need to get it several times due to AE stop
        // running while AWB is running, there is only 1 thread for 3A.
        // store = p_exp->exposure_log2;
    }
    lux = test_lux;
#else
    // EV to lux LUT:

    {
        uint8_t index = CALIBRATION_EVTOLUX_EV_LUT;
        uint32_t *evtolux_ev_lut = (uint32_t *)_GET_UINT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), index );

        if ( store < evtolux_ev_lut[0] ) {
            lux = _GET_UINT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_EVTOLUX_LUX_LUT )[0];
        } else if ( store >= evtolux_ev_lut[_GET_LEN( ACAMERA_FSM2CTX_PTR( p_fsm ), index ) - 1] ) {
            lux = _GET_UINT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_EVTOLUX_LUX_LUT )[_GET_LEN( ACAMERA_FSM2CTX_PTR( p_fsm ), index ) - 1];
        } else {
            for ( _i = 1; _i < _GET_LEN( ACAMERA_FSM2CTX_PTR( p_fsm ), index ); _i++ ) {
                if ( store < evtolux_ev_lut[_i] )
                    break;
            }
            lux = interpl( store, evtolux_ev_lut[_i - 1], _GET_UINT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_EVTOLUX_LUX_LUT )[_i - 1], evtolux_ev_lut[_i], _GET_UINT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_EVTOLUX_LUX_LUT )[_i] );
        }
    }
#endif


    //
    // - Calculate probabilities from tables
    //

    if ( lux > 5000 ) {
        p_lux_highTemp = 99;
        p_lux_lowTemp = 1;
    } else {
        p_lux_highTemp = luts_lux_high( p_fsm, lux );
        p_lux_lowTemp = luts_lux_low( p_fsm, lux );
    }

#ifdef AWB_PRINT_DEBUG
    if ( ittcount == debugprintperiod )
        LOG( LOG_DEBUG, "EV = %ld LUT_lux = %04x p_lux_highTemp = %04x p_lux_lowTemp = %04x \n", p_exp->exposure_log2, lux, p_lux_highTemp, p_lux_lowTemp );
#endif

    //======================================================
    // - Light Corner Points
    //======================================================

    MinX = ACAMERA_MIN( _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_RG_POS )[0], _calibration_light_src[0][0] );
    MinY = ACAMERA_MIN( _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_BG_POS )[0], _calibration_light_src[0][1] );

    MaxX = ACAMERA_MAX( _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_RG_POS )[_GET_LEN( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_RG_POS ) - 1], _calibration_light_src[0][0] );


    MaxY = ACAMERA_MAX( _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_BG_POS )[_GET_LEN( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_BG_POS ) - 1], _calibration_light_src[0][1] );

    for ( _i = 1; _i < _GET_ROWS( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_LIGHT_SRC ); _i++ ) {
        if ( _calibration_light_src[_i][0] < MinX )
            MinX = _calibration_light_src[_i][0];
        if ( _calibration_light_src[_i][1] < MinY )
            MinY = _calibration_light_src[_i][1];
        if ( _calibration_light_src[_i][0] > MaxX )
            MaxX = _calibration_light_src[_i][0];
        if ( _calibration_light_src[_i][1] > MaxY )
            MaxY = _calibration_light_src[_i][1];
    }

    //
    // - Main loop:
    //
    npccount = 0;
    npcLsum = npcHsum = 0;

    for ( _i = 0; _i < p_fsm->curr_AWB_ZONES; _i++ ) {
        rg = p_fsm->awb_zones[_i].rg;
        bg = p_fsm->awb_zones[_i].bg;

        // See if we're within the validity rectangle
        clipRG = ( ( rg >= MinX ) && ( rg <= MaxX ) );
        clipBG = ( ( bg >= MinY ) && ( bg <= MaxY ) );
        valid_zone = ( clipRG && clipBG && ( p_fsm->awb_zones[_i].sum > 256 ) );
        mvalid[_i] = valid_zone;

        if ( valid_zone ) {

            weight = AWB_mesh( p_fsm, (uint32_t)rg, (uint32_t)bg, (int16_t *)_GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_RG_POS ), (int16_t *)_GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_BG_POS ), (int16_t *)_GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_MESH_RGBG_WEIGHT ), 0 );

            // Extra light source probabilities
            for ( _j = 0; _j < _GET_ROWS( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_LIGHT_SRC ); _j++ ) {
                weight_ls = mesh_AWB_getKnownSourceLight_weight_LUT( p_fsm, rg, bg, _calibration_light_src[_j][0], _calibration_light_src[_j][1] );
                // +15 to stop false positives
                if ( ( weight_ls >= 20 ) && ( weight_ls > ( weight + 15 ) ) ) {
                    weight = weight_ls;
                    if ( _j == 0 )
                        cwfzones[_i] = 1;
                }
            }
            weight = ACAMERA_MAX( weight, 0 );
            if ( weight < 60 ) {
                // insignificant weight (Err_TOLERANCE_2)
                weight = 0;
                mvalid[_i] = 0;
            } else {
                // significant weight
                weight_[_i] = weight;

                p_rg_highTemp = luts_rg_high( p_fsm, rg );
                p_rg_lowTemp = luts_rg_low( p_fsm, rg );


                npcH = p_highTemp * p_rg_highTemp * p_lux_highTemp;
                npcL = p_lowTemp * p_rg_lowTemp * p_lux_lowTemp;
                store = npcH + npcL;
                if ( store != 0 ) {
                    npcHigh[_i] = ( 100 * npcH ) / store; // division by zero is checked
                    npcLow[_i] = ( 100 * npcL ) / store;  // division by zero is checked
                } else {
                    npcHigh[_i] = ( 100 * npcH );
                    npcLow[_i] = ( 100 * npcL );
                    LOG( LOG_ERR, "AVOIDED DIVISION BY ZERO" );
                }
                npcHsum += npcHigh[_i];
                npcLsum += npcLow[_i];
                npccount++;
            } // end significant weight

        } // end valid_zone

    } // end main loop


    //
    // - NBP decision
    //

    if ( npccount > 0 ) {
        npcHmean = npcHsum / npccount; // division by zero is checked
        npcLmean = npcLsum / npccount; // division by zero is checked
    } else {
        // No strong zones, allow the calculation to fail to last known
        // with the code below
        npcHmean = 50;
        npcLmean = 50;
    }

    uint8_t evtolux_probability_enable = _GET_UCHAR_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_EVTOLUX_PROBABILITY_ENABLE )[0];
    if ( evtolux_probability_enable == 0 ) {
        npcHmean = 50;
        npcLmean = 50;
        lux = 500;
    }

    p_fsm->p_high = npcHmean;
    p_fsm->p_low = npcLmean;

    uint32_t enable_awb_mix_light = _GET_UINT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_AWB_MIX_LIGHT_PARAMETERS )[0];
    uint32_t lux_low = _GET_UINT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_AWB_MIX_LIGHT_PARAMETERS )[1];
    uint32_t lux_high = _GET_UINT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_AWB_MIX_LIGHT_PARAMETERS )[2];
    uint32_t contrast_threshold = _GET_UINT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_AWB_MIX_LIGHT_PARAMETERS )[3];
    uint32_t bg_threshold = _GET_UINT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_AWB_MIX_LIGHT_PARAMETERS )[4];
    uint32_t bg_weight = _GET_UINT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_AWB_MIX_LIGHT_PARAMETERS )[5];
    uint32_t rgHigh_LUT_max = _GET_UINT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_AWB_MIX_LIGHT_PARAMETERS )[6];
    uint32_t rgHigh_LUT_min = _GET_UINT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_AWB_MIX_LIGHT_PARAMETERS )[7];
    uint32_t print_debug = _GET_UINT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_AWB_MIX_LIGHT_PARAMETERS )[8];
    uint16_t rg_weight = 0;
    status_info_param_t *p_status_info = (status_info_param_t *)_GET_UINT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_STATUS_INFO );

    uint32_t iridix_contrast = 256; //remove the 8 bit presicion?
    acamera_fsm_mgr_get_param( p_fsm->cmn.p_fsm_mgr, FSM_PARAM_GET_IRIDIX_CONTRAST, NULL, 0, &iridix_contrast, sizeof( iridix_contrast ) );

    p_status_info->awb_info.mix_light_contrast = iridix_contrast;


    if ( print_debug )
        LOG( LOG_NOTICE, "lux: %d, contrast from Iridix: %u", lux, (unsigned int)iridix_contrast );

    if ( enable_awb_mix_light && lux > lux_low && lux < lux_high && iridix_contrast > contrast_threshold ) {

        if ( print_debug )
            LOG( LOG_NOTICE, "mix light" );

        for ( _i = 0; _i < p_fsm->curr_AWB_ZONES; _i++ ) {
            rg = p_fsm->awb_zones[_i].rg;

            rg_weight = luts_fetch( rg, rgHigh_LUT_min, rgHigh_LUT_max, 1, (int16_t *)rghigh_lut, ARR_SIZE( rghigh_lut ) );
            rg_weight = ( 100 * rg_weight ) / rghigh_lut[0];

            weight_[_i] = ( mvalid[_i] ? ( weight_[_i] * rg_weight ) : 0 );

            bg = p_fsm->awb_zones[_i].bg;
            if ( bg > bg_threshold ) {
                weight_[_i] = ( mvalid[_i] ? bg_weight : 0 );

                if ( print_debug )
                    LOG( LOG_NOTICE, "remove bg" );
            }
        }
    } else if ( ( ( npcHmean >= npcLmean ) && ( npcHmean - npcLmean < 15 ) ) || ( ( npcHmean < npcLmean ) && ( npcLmean - npcHmean < 15 ) ) ) {
        // Case : probabilities are about the same
        if ( lux < 10 ) {
            // Low light

            for ( _i = 0; _i < p_fsm->curr_AWB_ZONES; _i++ ) {
                if ( mvalid[_i] && p_fsm->awb_zones[_i].rg >= _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_CT_RG_POS_CALC )[_GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_CT65POS )[0]] && p_fsm->awb_zones[_i].bg <= _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_CT_BG_POS_CALC )[_GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_CT65POS )[0]] ) { // division by zero is checked
                    weight_[_i] = weight_[_i] * npcLow[_i];
                } else {
                    weight_[_i] = 0;
                }
            }
        } else {
            // Not bright or dark
            for ( _i = 0; _i < p_fsm->curr_AWB_ZONES; _i++ ) {
                weight_[_i] = ( mvalid[_i] ? 100 * weight_[_i] : 0 );
            }
        }
    } else if ( npcLmean > npcHmean ) {
        // likely we're in a dark situation
        for ( _i = 0; _i < p_fsm->curr_AWB_ZONES; _i++ ) {
            weight_[_i] = ( mvalid[_i] ? weight_[_i] * npcLow[_i] : 0 );
        }
    } else {
        // likely we're in a light situation

        if ( lux > _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_SKY_LUX_TH )[0] ) {
            adjust_sky = 1;
        }

        avg_BG = 0;
        for ( _i = 0; _i < p_fsm->curr_AWB_ZONES; _i++ ) {
            avg_BG += p_fsm->awb_zones[_i].bg;
        }
        if ( p_fsm->curr_AWB_ZONES )
            avg_BG /= p_fsm->curr_AWB_ZONES; // division by zero is checked

        if ( lux > _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_SKY_LUX_TH )[0] && avg_BG > 246 ) {
            // looks like a sky scene
            sky_cut_high = _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_CT_RG_POS_CALC )[_GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_CT65POS )[0]];

            for ( _j = 25; _j <= 65; _j += 20 ) {
                // NOTE : these are flip rt to matlab to save on vaariables
                sky_cut_low = ( ( 950 + _j ) * ( ( _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_CT_RG_POS_CALC )[_GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_CT40POS )[0]] + 256 ) >> 1 ) ) / 1000; // division by zero is checked

                sky_cut_high_bg = ( 950 + _j > 1000 ? _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_CT_BG_POS_CALC )[_GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_CT65POS )[0]] : ( ( 950 + _j ) * _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_CT_BG_POS_CALC )[_GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_CT65POS )[0]] ) / 1000 ); // division by zero is checked

                sum = 0;
                for ( _i = 0; _i < p_fsm->curr_AWB_ZONES; _i++ ) {
                    if ( ( p_fsm->awb_zones[_i].rg >= sky_cut_high ) && ( p_fsm->awb_zones[_i].rg <= sky_cut_low ) && ( p_fsm->awb_zones[_i].bg <= sky_cut_high_bg ) ) { // division by zero is checked
                        sky_zones[_i] = 1;
                    } else {
                        sky_zones[_i] = 0;
                    }
                    store = weight_[_i] * mvalid[_i] * npcHigh[_i] * sky_zones[_i];
                    sum += store;
                }
                if ( sum != 0 ) {
                    break;
                }
            }
            for ( _i = 0; _i < p_fsm->curr_AWB_ZONES; _i++ ) {
                weight_[_i] = weight_[_i] * mvalid[_i] * npcHigh[_i] * sky_zones[_i];
            }

        } else {
            // general bright scene
            for ( _i = 0; _i < p_fsm->curr_AWB_ZONES; _i++ ) {
                weight_[_i] = ( mvalid[_i] ? weight_[_i] * npcHigh[_i] : 0 );
            }
        }
    }

    //
    // - CWF
    //

    sum = 0;
    for ( _i = 0; _i < p_fsm->curr_AWB_ZONES; _i++ )
        sum += cwfzones[_i];
    // strictly less-than to combat integer rounding
    if ( sum > ( p_fsm->curr_AWB_ZONES >> 3 ) && npcLmean > npcHmean && lux > 100 && lux <= 900 ) {
        // lots of CWF zones - keep CWF zones
        for ( _i = 0; _i < p_fsm->curr_AWB_ZONES; _i++ ) {
            rg_valid[_i] = p_fsm->awb_zones[_i].rg * mvalid[_i] * cwfzones[_i]; // division by zero is checked
            bg_valid[_i] = p_fsm->awb_zones[_i].bg * mvalid[_i] * cwfzones[_i]; // division by zero is checked
            weight_[_i] = weight_[_i] * cwfzones[_i];
        }
    } else if ( sum >= 1 && lux > 900 ) {
        // A few CWF zones - keep non-CWF zones
        for ( _i = 0; _i < p_fsm->curr_AWB_ZONES; _i++ ) {
            {
                rg_valid[_i] = p_fsm->awb_zones[_i].rg * mvalid[_i] * ( 1 - cwfzones[_i] ) * sky_zones[_i]; // division by zero is checked
                bg_valid[_i] = p_fsm->awb_zones[_i].bg * mvalid[_i] * ( 1 - cwfzones[_i] ) * sky_zones[_i]; // division by zero is checked
                weight_[_i] = weight_[_i] * ( 1 - cwfzones[_i] );
            }
        }
    } else {
        // Definately not CWF
        for ( _i = 0; _i < p_fsm->curr_AWB_ZONES; _i++ ) {


            rg_valid[_i] = p_fsm->awb_zones[_i].rg * mvalid[_i] * sky_zones[_i]; // division by zero is checked
            bg_valid[_i] = p_fsm->awb_zones[_i].bg * mvalid[_i] * sky_zones[_i]; // division by zero is checked
        }
    }

    //
    // - norm_p checks
    //
    sum = 0;
    for ( _i = 0; _i < p_fsm->curr_AWB_ZONES; _i++ )
        sum += weight_[_i];

#ifdef AWB_PRINT_DEBUG
    if ( ittcount == debugprintperiod )
        LOG( LOG_DEBUG, "Final weight sum = %08lx\n", sum );
#endif

    if ( sum == 0 ) {
        // no valid zones
        avg_RG = 0;
        for ( _i = 0; _i < p_fsm->curr_AWB_ZONES; _i++ ) {
            avg_RG += p_fsm->awb_zones[_i].rg;
        }
        if ( p_fsm->curr_AWB_ZONES )
            avg_RG /= p_fsm->curr_AWB_ZONES; // division by zero is checked

        if ( avg_RG > _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_CT_RG_POS_CALC )[_GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_CT30POS )[0]] ) { // division by zero is checked
            avg_RG = _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_CT_RG_POS_CALC )[_GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_CT30POS )[0]];
            avg_BG = _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_CT_BG_POS_CALC )[_GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_CT30POS )[0]];

        } else {
            avg_RG = 256; //p_fsm->stable_avg_RG;
            avg_BG = 256; //p_fsm->stable_avg_BG;
        }
    } else {
        // at least some valid zones
        avg_BG = avg_RG = 0;
        for ( _i = 0; _i < p_fsm->curr_AWB_ZONES; _i++ ) {
            avg_RG += (uint64_t)rg_valid[_i] * weight_[_i];
            avg_BG += (uint64_t)bg_valid[_i] * weight_[_i];
        }
        if ( sum ) {
            avg_BG /= sum; // division by zero is checked
            avg_RG /= sum; // division by zero is checked
        }

        //To Store the last stable Light Source.
        p_fsm->stable_avg_BG = avg_BG;
        p_fsm->stable_avg_RG = avg_RG;
    }

    //
    // - adjust sky
    //
    if ( adjust_sky && _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_WB_STRENGTH )[2] ) {
        avg_RG = ( _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_WB_STRENGTH )[0] * avg_RG ) / _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_WB_STRENGTH )[2]; // division by zero is checked
        avg_BG = ( _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_WB_STRENGTH )[1] * avg_BG ) / _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_WB_STRENGTH )[2]; // division by zero is checked
    }
    // if we have no clue what to do - do nothing!!!
    avg_RG = ( avg_RG ? avg_RG : p_fsm->stable_avg_RG );
    avg_BG = ( avg_BG ? avg_BG : p_fsm->stable_avg_BG );

#if AWB_BG_MAX_GAIN
    // Clip maxium gains for rg and bg according to gain
    int32_t total_gain = 0; // Get the total gain from general rounter.
    acamera_fsm_mgr_get_param( p_fsm->cmn.p_fsm_mgr, FSM_PARAM_GET_CMOS_TOTAL_GAIN, NULL, 0, &total_gain, sizeof( total_gain ) );
    uint16_t log2_gain = total_gain >> ( LOG2_GAIN_SHIFT - 8 );

    int16_t max_bg_gain = acamera_calc_modulation_u16( log2_gain, _GET_MOD_ENTRY16_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_AWB_BG_MAX_GAIN ), _GET_ROWS( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_AWB_BG_MAX_GAIN ) );

    if ( avg_BG < max_bg_gain ) {
        avg_BG = max_bg_gain;
    }
#endif

    if ( avg_RG && avg_BG ) {
        GRres = U16_MAX / avg_RG; // division by zero is checked
        GBres = U16_MAX / avg_BG; // division by zero is checked
    } else {
        LOG( LOG_ERR, "AVOIDED DIVISION BY ZERO" );
    }

#ifdef AWB_SMOOTH_FILTER
    interp_2d_point_t point;
    fifo_push( p_fsm, GRres, GBres );
    point = get_point( p_fsm );
    p_fsm->avg_GR = point.x;
    p_fsm->avg_GB = point.y;


#else
    p_fsm->avg_GR = GRres;
    p_fsm->avg_GB = GBres;
#endif


#ifdef AWB_PRINT_DEBUG
    clipRG = 0;
#endif

    if ( !ACAMERA_FSM2CTX_PTR( p_fsm )->stab.global_manual_awb ) {

        // Only set the values if we're not in manual mode
        if ( p_fsm->avg_GR && p_fsm->avg_GB ) {

            temp_cal = AWB_mesh( p_fsm, ( uint32_t )( U16_MAX / p_fsm->avg_GR ), ( uint32_t )( U16_MAX / p_fsm->avg_GB ), (int16_t *)_GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_RG_POS ), (int16_t *)_GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_BG_POS ), (int16_t *)_GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_MESH_COLOR_TEMPERATURE ), 1 ); // division by zero is checked
            if ( temp_cal )
                temp_cal = 1000000 / temp_cal; // division by zero is checked

            if ( temp_cal < p_fsm->min_temp ) {
#ifdef AWB_PRINT_DEBUG
                clipRG = 1;
#endif
                temp_cal = p_fsm->min_temp;
                p_fsm->rg_coef = p_fsm->min_temp_rg;
                p_fsm->bg_coef = p_fsm->min_temp_bg;

            } else if ( temp_cal > p_fsm->max_temp ) {
#ifdef AWB_PRINT_DEBUG
                clipRG = 2;
#endif
                temp_cal = p_fsm->max_temp;
                p_fsm->rg_coef = p_fsm->max_temp_rg;
                p_fsm->bg_coef = p_fsm->max_temp_bg;

            } else {
                p_fsm->rg_coef = p_fsm->avg_GR;
                p_fsm->bg_coef = p_fsm->avg_GB;
            }
        }
    } else {
        {
            temp_cal = AWB_mesh( p_fsm, ( uint32_t )( p_fsm->rg_coef ? U16_MAX / p_fsm->rg_coef : U16_MAX ), ( uint32_t )( p_fsm->bg_coef ? U16_MAX / p_fsm->bg_coef : U16_MAX ), (int16_t *)_GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_RG_POS ), (int16_t *)_GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_BG_POS ), (int16_t *)_GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_MESH_COLOR_TEMPERATURE ), 1 ); // division by zero is checked
            if ( temp_cal )
                temp_cal = 1000000 / temp_cal; // division by zero is checked
        }
    }

    p_fsm->temperature_detected = temp_cal;

    if ( print_debug )
        LOG( LOG_INFO, "lux %d plow %d phigh %d temp_cal %d rg_coef %d bg_coef %d\n", (int)lux, (int)npcLmean, (int)npcHmean, (int)temp_cal, (int)p_fsm->rg_coef, (int)p_fsm->bg_coef );

#ifdef AWB_PRINT_DEBUG
    if ( ittcount == debugprintperiod )
        LOG( LOG_DEBUG, "PLow = %02x PHigh = %02x Manual = %02x Clipped = %02x rg_coef = %08x bg_coef = %08x temp_cal = %ld\n", npcLmean, npcHmean, ACAMERA_FSM2CTX_PTR( p_fsm )->stab.global_manual_awb, clipRG, p_fsm->rg_coef, p_fsm->bg_coef, temp_cal );
#endif
}

void awb_calc_avg_weighted_gr_gb( AWB_fsm_t *p_fsm )
{
    awb_calc_avg_weighted_gr_gb_mesh( p_fsm );
}

//    For CCM switching
void awb_detect_light_source( AWB_fsm_t *p_fsm )
{
    p_fsm->light_source_candidate = AWB_LIGHT_SOURCE_A;
    if ( p_fsm->temperature_detected <= AWB_DLS_LIGHT_SOURCE_A_D40_BORDER ) {
        p_fsm->light_source_candidate = AWB_LIGHT_SOURCE_A;
    } else if ( p_fsm->temperature_detected <= AWB_DLS_LIGHT_SOURCE_D40_D50_BORDER ) {
        p_fsm->light_source_candidate = AWB_LIGHT_SOURCE_D40;
    } else {
        p_fsm->light_source_candidate = AWB_LIGHT_SOURCE_D50;
    }
}

//    For CCM switching
void awb_process_light_source( AWB_fsm_t *p_fsm )
{
    int32_t total_gain = 0;
    int high_gain = 0;

    acamera_fsm_mgr_get_param( p_fsm->cmn.p_fsm_mgr, FSM_PARAM_GET_CMOS_TOTAL_GAIN, NULL, 0, &total_gain, sizeof( total_gain ) );

    high_gain = ( total_gain >> ( LOG2_GAIN_SHIFT - 8 ) ) >= _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_CCM_ONE_GAIN_THRESHOLD )[0];

    fsm_param_ccm_info_t ccm_info;
    acamera_fsm_mgr_get_param( p_fsm->cmn.p_fsm_mgr, FSM_PARAM_GET_CCM_INFO, NULL, 0, &ccm_info, sizeof( ccm_info ) );

    if ( p_fsm->p_high > 60 ) {
        ++p_fsm->detect_light_source_frames_count;
        if ( p_fsm->detect_light_source_frames_count >= p_fsm->switch_light_source_detect_frames_quantity ) {
#ifdef AWB_PRINT_DEBUG
            if ( ccm_info.light_source != AWB_LIGHT_SOURCE_D50 ) {
                LOG( LOG_DEBUG, "Light source is changed\n" );
                LOG( LOG_DEBUG, "p_high=%d, using AWB_LIGHT_SOURCE_D50\n", p_fsm->p_high );
            }
#endif

            ccm_info.light_source_previous = ccm_info.light_source;
            ccm_info.light_source = p_fsm->light_source_candidate;
            ccm_info.light_source_ccm_previous = ccm_info.light_source_ccm;
            ccm_info.light_source_ccm = high_gain ? AWB_LIGHT_SOURCE_UNKNOWN : p_fsm->light_source_candidate; // for low light set ccm = I
            ccm_info.light_source_change_frames = p_fsm->switch_light_source_change_frames_quantity;
            ccm_info.light_source_change_frames_left = p_fsm->switch_light_source_change_frames_quantity;

            acamera_fsm_mgr_set_param( p_fsm->cmn.p_fsm_mgr, FSM_PARAM_SET_CCM_INFO, &ccm_info, sizeof( ccm_info ) );
        }

    } else if ( p_fsm->light_source_detected == p_fsm->light_source_candidate ) {
        if ( ( p_fsm->light_source_candidate != ccm_info.light_source ) || ( high_gain && ccm_info.light_source_ccm != AWB_LIGHT_SOURCE_UNKNOWN ) || ( !high_gain && ccm_info.light_source_ccm == AWB_LIGHT_SOURCE_UNKNOWN ) ) {
            ++p_fsm->detect_light_source_frames_count;
            if ( p_fsm->detect_light_source_frames_count >= p_fsm->switch_light_source_detect_frames_quantity && !ccm_info.light_source_change_frames_left ) {
                ccm_info.light_source_previous = ccm_info.light_source;
                ccm_info.light_source = p_fsm->light_source_candidate;
                ccm_info.light_source_ccm_previous = ccm_info.light_source_ccm;
                ccm_info.light_source_ccm = high_gain ? AWB_LIGHT_SOURCE_UNKNOWN : p_fsm->light_source_candidate; // for low light set ccm = I
                ccm_info.light_source_change_frames = p_fsm->switch_light_source_change_frames_quantity;
                ccm_info.light_source_change_frames_left = p_fsm->switch_light_source_change_frames_quantity;
                acamera_fsm_mgr_set_param( p_fsm->cmn.p_fsm_mgr, FSM_PARAM_SET_CCM_INFO, &ccm_info, sizeof( ccm_info ) );

#ifdef AWB_PRINT_DEBUG
                // These are rarer so can print wherever they are fired (i.e. not dependent on ittcount)
                LOG( LOG_DEBUG, "Light source is changed\n" );
                if ( ccm_info.light_source == AWB_LIGHT_SOURCE_A )
                    LOG( LOG_DEBUG, "AWB_LIGHT_SOURCE_A\n" );
                if ( ccm_info.light_source == AWB_LIGHT_SOURCE_D40 )
                    LOG( LOG_DEBUG, "AWB_LIGHT_SOURCE_D40\n" );
                if ( ccm_info.light_source == AWB_LIGHT_SOURCE_D50 )
                    LOG( LOG_DEBUG, "AWB_LIGHT_SOURCE_D50\n" );
#endif
            }
        }
    } else {
        p_fsm->detect_light_source_frames_count = 0;
    }
    p_fsm->light_source_detected = p_fsm->light_source_candidate;
}

// Write the values
void awb_update( AWB_fsm_t *p_fsm )
{
    /*  
        This function drives the cooling warming effect according to colour temperature.
        See kruithof curve for a reference and background theory about this functionality
        Tuning luts default
        CALIBRATION_AWB_WARMING_LS_A = {256,256,256}; //u4.8
        CALIBRATION_AWB_WARMING_LS_D50= {256,256,256};//u4.8
        CALIBRATION_AWB_WARMING_LS_D75= {256,256,256};//u4.8
        AWB_colour_preference={7500,6000,4700,2800};// in Kelvin

        | blue gain
        |    .                    .    .
        |        .            .
        |            . .  . .
        |        .              .
        |Red. gain                        .
        |.                            .
        -----|------|------|--------|-------
            70000  6000    4700     2800    CCT in kelvin
    */

    int32_t temperature = p_fsm->temperature_detected;
    p_fsm->awb_warming_A[0] = ( int32_t )( _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_AWB_WARMING_LS_A )[0] ) << 8;
    p_fsm->awb_warming_A[1] = ( int32_t )( _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_AWB_WARMING_LS_A )[1] ) << 8;
    p_fsm->awb_warming_A[2] = ( int32_t )( _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_AWB_WARMING_LS_A )[2] ) << 8;

    p_fsm->awb_warming_D75[0] = ( int32_t )( _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_AWB_WARMING_LS_D75 )[0] ) << 8; //TO DO: this is wrong lut. it should be D75
    p_fsm->awb_warming_D75[1] = ( int32_t )( _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_AWB_WARMING_LS_D75 )[1] ) << 8; //TO DO: this is wrong lut. it should be D75
    p_fsm->awb_warming_D75[2] = ( int32_t )( _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_AWB_WARMING_LS_D75 )[2] ) << 8; //TO DO: this is wrong lut. it should be D75

    p_fsm->awb_warming_D50[0] = ( int32_t )( _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_AWB_WARMING_LS_D50 )[0] ) << 8;
    p_fsm->awb_warming_D50[1] = ( int32_t )( _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_AWB_WARMING_LS_D50 )[1] ) << 8;
    p_fsm->awb_warming_D50[2] = ( int32_t )( _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_AWB_WARMING_LS_D50 )[2] ) << 8;

    // calibration table: AWB Colour preference
    //int16_t AWB_colour_preference[4] = {7500,6000,4700,2800};
    const int16_t *AWB_colour_preference = (int16_t *)_GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), AWB_COLOUR_PREFERENCE );
    int16_t m = 0;
    if ( temperature >= AWB_colour_preference[1] ) {
        //high temp

        //RED
        int awb_red_pref = ( AWB_colour_preference[1] - AWB_colour_preference[0] );
        if ( awb_red_pref == 0 ) {
            awb_red_pref = 1;
        }

        m = ( p_fsm->awb_warming_D50[0] - p_fsm->awb_warming_D75[0] ) / awb_red_pref;
        if ( m == 0 ) {
            p_fsm->awb_warming[0] = p_fsm->awb_warming_D50[0] >> 8;
        } else {
            p_fsm->awb_warming[0] = ( m * ( temperature - AWB_colour_preference[0] ) + p_fsm->awb_warming_D75[0] ) >> 8;
        }

        //GREEN
        int awb_green_pref = ( AWB_colour_preference[1] - AWB_colour_preference[0] );
        if ( awb_green_pref == 0 ) {
            awb_green_pref = 1;
        }
        m = ( p_fsm->awb_warming_D50[1] - p_fsm->awb_warming_D75[1] ) / awb_green_pref;
        if ( m == 0 ) {
            p_fsm->awb_warming[1] = p_fsm->awb_warming_D50[1] >> 8;
        } else {
            p_fsm->awb_warming[1] = ( m * ( temperature - AWB_colour_preference[0] ) + p_fsm->awb_warming_D75[1] ) >> 8;
        }
        //BLUE
        int awb_blue_pref = ( AWB_colour_preference[1] - AWB_colour_preference[0] );
        if ( awb_blue_pref == 0 ) {
            awb_blue_pref = 1;
        }
        m = ( p_fsm->awb_warming_D50[2] - p_fsm->awb_warming_D75[2] ) / awb_blue_pref;
        if ( m == 0 ) {
            p_fsm->awb_warming[2] = p_fsm->awb_warming_D50[2] >> 8;
        } else {
            p_fsm->awb_warming[2] = ( m * ( temperature - AWB_colour_preference[0] ) + p_fsm->awb_warming_D75[2] ) >> 8;
        }
        // printf("1 temp %d r %d g %d b %d \n",(int)temperature,(int)(p_fsm->awb_warming[0]),(int)(p_fsm->awb_warming[1]),(int)(p_fsm->awb_warming[2]) );

    } else if ( temperature <= AWB_colour_preference[2] ) {
        //low temp
        int awb_red_pref = ( AWB_colour_preference[3] - AWB_colour_preference[2] );
        if ( awb_red_pref == 0 ) {
            awb_red_pref = 1;
        }
        m = ( p_fsm->awb_warming_A[0] - p_fsm->awb_warming_D50[0] ) / awb_red_pref;
        if ( m == 0 ) {
            p_fsm->awb_warming[0] = p_fsm->awb_warming_D50[0] >> 8;
        } else {
            p_fsm->awb_warming[0] = ( m * ( temperature - AWB_colour_preference[3] ) + p_fsm->awb_warming_A[0] ) >> 8;
        }
        //GREN
        int awb_green_pref = ( AWB_colour_preference[3] - AWB_colour_preference[2] );
        if ( awb_green_pref == 0 ) {
            awb_green_pref = 1;
        }
        m = ( p_fsm->awb_warming_A[1] - p_fsm->awb_warming_D50[1] ) / awb_green_pref;
        if ( m == 0 ) {
            p_fsm->awb_warming[1] = p_fsm->awb_warming_D50[1] >> 8;
        } else {
            p_fsm->awb_warming[1] = ( m * ( temperature - AWB_colour_preference[3] ) + p_fsm->awb_warming_A[1] ) >> 8;
        }
        //BLUE
        int awb_blue_pref = ( AWB_colour_preference[3] - AWB_colour_preference[2] );
        if ( awb_blue_pref == 0 ) {
            awb_blue_pref = 1;
        }
        m = ( p_fsm->awb_warming_A[2] - p_fsm->awb_warming_D50[2] ) / awb_blue_pref;
        if ( m == 0 ) {
            p_fsm->awb_warming[2] = p_fsm->awb_warming_D50[2] >> 8;
        } else {
            p_fsm->awb_warming[2] = ( m * ( temperature - AWB_colour_preference[3] ) + p_fsm->awb_warming_A[2] ) >> 8;
        }
        // printf("2 temp %d r %d g %d b %d \n",(int)temperature,(int)(p_fsm->awb_warming[0]),(int)(p_fsm->awb_warming[1]),(int)(p_fsm->awb_warming[2]) );
    } else {
        //mid temp
        p_fsm->awb_warming[0] = p_fsm->awb_warming_D50[0] >> 8;
        p_fsm->awb_warming[1] = p_fsm->awb_warming_D50[1] >> 8;
        p_fsm->awb_warming[2] = p_fsm->awb_warming_D50[2] >> 8;
        // printf("3 temp %d r %d g %d b %d \n",(int)temperature,(int)(p_fsm->awb_warming[0]),(int)(p_fsm->awb_warming[1]),(int)(p_fsm->awb_warming[2]) );
    }
}

// Perform normalisation
void awb_normalise( AWB_fsm_t *p_fsm )
{
    int32_t wb[4];

    wb[0] = acamera_log2_fixed_to_fixed( _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_STATIC_WB )[0], 8, LOG2_GAIN_SHIFT );
    wb[1] = acamera_log2_fixed_to_fixed( _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_STATIC_WB )[1], 8, LOG2_GAIN_SHIFT );
    wb[2] = acamera_log2_fixed_to_fixed( _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_STATIC_WB )[2], 8, LOG2_GAIN_SHIFT );
    wb[3] = acamera_log2_fixed_to_fixed( _GET_USHORT_PTR( ACAMERA_FSM2CTX_PTR( p_fsm ), CALIBRATION_STATIC_WB )[3], 8, LOG2_GAIN_SHIFT );

    {
        if ( ACAMERA_FSM2CTX_PTR( p_fsm )->stab.global_manual_awb ) {
            wb[0] += acamera_log2_fixed_to_fixed( ACAMERA_FSM2CTX_PTR( p_fsm )->stab.global_awb_red_gain, 8, LOG2_GAIN_SHIFT );
            wb[3] += acamera_log2_fixed_to_fixed( ACAMERA_FSM2CTX_PTR( p_fsm )->stab.global_awb_blue_gain, 8, LOG2_GAIN_SHIFT );
            p_fsm->rg_coef = ACAMERA_FSM2CTX_PTR( p_fsm )->stab.global_awb_red_gain;
            p_fsm->bg_coef = ACAMERA_FSM2CTX_PTR( p_fsm )->stab.global_awb_blue_gain;
        } else {
            wb[0] += acamera_log2_fixed_to_fixed( p_fsm->rg_coef, 8, LOG2_GAIN_SHIFT );
            wb[3] += acamera_log2_fixed_to_fixed( p_fsm->bg_coef, 8, LOG2_GAIN_SHIFT );
            ACAMERA_FSM2CTX_PTR( p_fsm )
                ->stab.global_awb_red_gain = p_fsm->rg_coef;
            ACAMERA_FSM2CTX_PTR( p_fsm )
                ->stab.global_awb_blue_gain = p_fsm->bg_coef;
        }
    }
    {
        int i;
        int32_t min_wb = wb[0];
        for ( i = 1; i < 4; ++i ) {
            int32_t _wb = wb[i];
            if ( min_wb > _wb ) {
                min_wb = _wb;
            }
        }

        fsm_param_sensor_info_t sensor_info;
        acamera_fsm_mgr_get_param( p_fsm->cmn.p_fsm_mgr, FSM_PARAM_GET_SENSOR_INFO, NULL, 0, &sensor_info, sizeof( sensor_info ) );

        int32_t diff = ( ISP_INPUT_BITS << LOG2_GAIN_SHIFT ) - acamera_log2_fixed_to_fixed( ( 1 << ISP_INPUT_BITS ) - sensor_info.black_level, 0, LOG2_GAIN_SHIFT ) - min_wb;
        for ( i = 0; i < 4; ++i ) {
            int32_t _wb = wb[i] + diff;
            p_fsm->wb_log2[i] = _wb;
        }
    }

    // skip when frame_id is 0.
    if ( p_fsm->cur_using_stats_frame_id ) {
        fsm_param_mon_alg_flow_t awb_flow;

        p_fsm->cur_result_gain_frame_id = p_fsm->cur_using_stats_frame_id;

        // prepare it for next time
        p_fsm->cur_using_stats_frame_id = 0;

        awb_flow.frame_id_tracking = p_fsm->cur_result_gain_frame_id;
        awb_flow.frame_id_current = acamera_fsm_util_get_cur_frame_id( &p_fsm->cmn );
        awb_flow.flow_state = MON_ALG_FLOW_STATE_OUTPUT_READY;
        acamera_fsm_mgr_set_param( p_fsm->cmn.p_fsm_mgr, FSM_PARAM_SET_MON_AWB_FLOW, &awb_flow, sizeof( awb_flow ) );
    }
}
